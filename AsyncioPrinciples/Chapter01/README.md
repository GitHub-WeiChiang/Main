Chapter01 簡介 Asyncio
=====
* ### Python 3 的 Asyncio: 可以在程式中執行多個並行 (concurrent) 的 HTTP 要求。
* ### Asyncio 改變了程式在架構時的思考模式。
* ### Asyncio 著重的是，多個作業同時執行時，如何做到最好。
* ### Asyncio 並不是什麼作業都能處理，而是那些涉及到等待的作業。
* ### Asyncio 在等待作業完成的這段時間，可以去執行其它作業。
* ### ThreadBots 餐廳故事的閉幕語
  * ### 電腦程式設計涉及網路設計時，CPU 執行作業並等待網路 I/O，現代電腦的 CPU 在運作時，速度會比網路訊息溝通快上幾十萬倍，因此，CPU 執行網路程式時，會耗費大量的等待時間。
  * ### Asyncio 的解決方案是，撰寫程式在必要時，明確要求 CPU 轉換作業。
  * ### 在經濟效益上，用比較少的 CPU 以相似的效能來做同樣的事 (Asyncio 在定義上是單執行緒)。
  * ### 相較於多執行緒，Asyncio 避免了競速 (Race Condition) 問題。
* ### Asyncio 想解決的問題 ?
  * ### 對於 I/O 密集式的作業，決定不使用執行緒，而採用非同步的並行方案，其實只有兩個理由:
    * ### 相較於先佔式多工 (Preemptive Multitasking)，也就是所謂的執行緒，Asyncio 是更安全的替代方案，可以避免複雜執行緒應用程式上常見的臭蟲、競速以及其它難以確認的風險。
    * ### 針對數以萬計的 Socket 連線，Asyncio 提供一個簡明的支援方式，像是處理多個 WebSocket 之類新技術的長時連線，或者是 IoT (Internet of Things) 應用程式的 MQTT。
  * ### 執行緒適用於運算作業，在多核心 CPU 執行，且共享記憶體，即便這是必要之惡。
  * ### 網路程式設計則非上述適用場景，網路程式設計涉及大量的 "等待某事發生"，不需要作業系統有效率地在多 CPU 上指派作業，進一步的也就不需要承擔先佔式多工帶來的風險，像是共享記憶體所造成的競速問題。
* ### 基於 "事件" 的設計模型不正確的認知
  * ### 
<br />
