Chapter19 說過的話就一定要做到 -- redo 記錄檔
=====
* ### 如何保證交易的持久性 ? 有一個粗暴的做法，只要交易提交就刷新到磁碟...
    * ### 刷新一個完整的資料頁太浪費了，InnoDB 以頁為單位進行磁碟 I/O 讀取，如果只是修改了一個位元組，就要刷新 16 KB 的資料到磁碟上，不要鬧了。
    * ### 隨機 I/O 會是一個問題，一行敘述可能修改到多個頁面，而頁面在物理上不一定相連的，隨機 I/O 遠比順序 I/O 要來得慢，尤其是在機械硬碟上更是明顯。
* ### 其實只要讓提交的交易對資料庫中資料所做的修改能夠永久生效即可，達到即便系統崩潰也能恢復的目標即可，沒有必要頻繁刷新頁面，僅需記錄修改內容。
* ### 每當交易提交時，只刷新修改的記錄到磁碟中。
* ### 記錄著交易修改內容的的檔案，被稱為 "重作記錄檔 (redo log)"，也稱為 "redo 記錄檔"。
* ### 僅刷新 "redo 記錄檔" 而非 "資料頁" 的好處:
    * ### redo 記錄檔佔用空非常小 (基本只有表格空間 ID、頁號、偏移量與更新值)。
    * ### redo 記錄檔是順序寫入磁碟的 (這意味著 順序 I/O)。
* ### redo 記錄檔格式
    ```
    (type)(space ID)(page number)(offset)(data)
    ```
    * ### type: redo 記錄檔類型 (MySQL 5.7.22 版中 InnoDB 共有 53 種類型)
    * ### space ID: 表格空間 ID。
    * ### page number: 頁號。
    * ### offset: 表頁面中的偏移量。
    * ### data: redo 記錄檔具體內容。
* ### 先來看一個案例
    * ### 如果沒有為某個表顯性的定義主鍵，且表中也沒有定義不允許儲存 NULL 值的 UNIQUE 鍵，那麼 InnoDB 會為表增加一個名為 row_id 的隱藏列作為主鍵。
    * ### 資料庫伺服器在記憶體中維護一個 "全域變數"。
    * ### 每當包含 row_id 隱藏列的表中插入一筆記錄，就將全域變數值作為 row_id 列值，並把 "全域變數" 加 1。
    * ### 每當 "全域變數" 為 256 的倍數，就將該變數刷新到系統表格空間頁號為 7 的頁面中一個名為 Max Row ID 的屬性 (避免頻繁寫入磁碟，"Max Row ID" 相關敘述可參考 Chapter09)。
    * ### 當系統啟動時，會將 Max Row ID 載入到記憶體中，並將該值加上 256 後指定給 "全域變數" (因為如果上次關機時，"全域變數" 並非 256 的倍數未被刷新至磁碟)。
    * ### 此案例會在 Buffer Pool 中完成，InnoDB 會針對此次修改以 redo 格式記錄。
    * ### 當交易提交後，即使系統崩潰，也可以將頁面恢復成崩潰前的狀態。
    * ### 上述的 redo 記錄檔非常簡單，就是某個頁面的某個偏移量的位置修改了幾個位元組的值以及具體修改內容。
    * ### 這種簡單的 redo 記錄檔被稱為物理記錄檔。
* ### redo 記錄檔根據在頁面中寫入的資料量劃分了幾種不同的類型
    * ### MLOG_1BYTE: 表示在頁面的某個偏移量處寫入了 1 位元組的 redo 記錄檔類型。
    * ### MLOG_2BYTE: 表示在頁面的某個偏移量處寫入了 2 位元組的 redo 記錄檔類型。
    * ### MLOG_4BYTE: 表示在頁面的某個偏移量處寫入了 4 位元組的 redo 記錄檔類型。
    * ### MLOG_8BYTE: 表示在頁面的某個偏移量處寫入了 8 位元組的 redo 記錄檔類型。
    * ### MLOG_WRITE_BYTE: 表示在頁面的某個偏移量處寫入一個位元組序列。
    * ### 前述的 Max Row ID 是使用 MLOG_8BYTE 類型。
    * ### 除了 MLOG_WRITE_BYTE 外，其餘類型格式大致相同，只是具體資料包含的位元組數不同而已。
    * ### MLOG_WRITE_BYTE 類型記錄檔格式如下 (多了一個 len 欄位記錄佔用位元組量)
        ```
        (type)(space ID)(page number)(offset)(len)(data)
        ```
    * ### MLOG_WRITE_BYTE 看似可以通用，但是，佔空間啊孩子。
* ### 執行一行敘述可能會修改多張頁面，包含系統資料頁面與使用者資料頁面 (也就是聚簇索引和二級索引對應的 B+ 樹)。
* ### 敘述對 B+ 樹所做的更新
    * ### 表中包含多少個索引，一筆 INSERT 敘述就可能更新多少棵 B+ 樹。
    * ### 針對某一顆 B+ 樹而言，既可能更新葉子節點頁面，也可能更新內節點頁面，甚至發生新頁面申請 (頁面分裂) 操作。
* ### 在將記錄插入到索引時，即便不用進行頁面分裂，除了更新該葉子節點的頁面記錄 (MLOG_WRITE_BYTE) 外，還有 File Header、Page Header、Page Directory 等部分。
* ### 這意味著，每往葉子節點代表的資料頁中插入一筆記錄，還有一堆東西要更新:
    * ### 可能更新 Page Directory 中的 slot 資訊。
    * ### 可能更新 Page Header 各種頁面統計資訊。
        * ### PAGE_N_DIR_SLOTS: 槽數量。
        * ### PAGE_HEAP_TOP: 未使用空間最小位址。
        * ### PAGE_N_HEAP: 當頁記錄數量。
        * ### 還有很多呢...
    * ### 還有，資料頁中的記錄按照索引由小到大排序病透過單向鏈結串列組成，插入一筆記錄還需要更新上一筆記錄的 next_record 屬性。
* ### 總之，將一筆記錄插入頁面，要修改很多很多地方，若僅使用上述的 redo 記錄檔類型作記錄，可以有以下兩種作法:
    * ### 在每個修改的地方都記錄一筆 redo 記錄檔，不過這可能造成 redo 記錄檔佔用的空間比整個頁面佔用的空間還多 (太多地方要修改了)。
    * ### 將整個頁面的第一個被修改的位元組到最後一個被修改的位元組之間的資料當成一筆物理 redo 記錄檔中的具體資料 (這麼浪費空間要不乾脆直接更新一整頁算了)。
* ### 為因應上述問題，InnoDB 工程師提出了一些新的 redo 記錄檔類型
    * ### To be Continued...
<br /> 
