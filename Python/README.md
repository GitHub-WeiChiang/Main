Python
=====
* ### Chapter01 Python 起步走
* ### Chapter02 從 REPL 到 IDE
* ### Chapter03 型態與運算子
* ### Chapter04 流程語法與函式
* ### Chapter05 從模組到類別
* ### Chapter06 類別的繼承
* ### Chapter07 例外處理
* ### Chapter08 open() 與 io 模組
* ### Chapter09 資料結構
* ### Chapter10 資料永續與交換
* ### Chapter11 常用內建模組
* ### Chapter12 除錯、測試與效能
* ### Chapter13 並行、平行與非同步
<br />

Note
=====
* ### CPU 密集型 (CPU - bound)
	* ### 也叫計算密集型，指的是系統的硬盤、內存性能相對 CPU 要好很多，此時，系統運作 CPU 讀寫 IO (硬盤 / 內存) 時，IO 可以在很短的時間內完成，而 CPU 還有許多運算要處理，因此，CPU 負載很高。
	* ### CPU 密集表示該任務需要大量的運算，而沒有阻塞，CPU 一直全速運行。CPU 密集任務只有在真正的多核 CPU 上才可能得到加速 (通過多線程)，而在單核 CPU 上，無論你開幾個模擬的多線程該任務都不可能得到加速，因為 CPU 總的運算能力就只有這麼多。
	* ### CPU 使用率較高 (例如: 計算圓周率、對視頻進行高清解碼、矩陣運算等情況) 的情況下，通常，線程數只需要設置為 CPU 核心數的線程個數就可以了。這一情況多出現在一些業務複雜的計算和邏輯處理過程中。比如說，現在的一些機器學習和深度學習的模型訓練和推理任務，包含了大量的矩陣運算。
* ### IO 密集型 (I/O - bound)
	* ### IO 密集型指的是系統的 CPU 性能相對硬盤、內存要好很多，此時，系統運作，大部分的狀況是 CPU 在等 IO (硬盤 / 內存) 的讀寫操作，因此，CPU 負載並不高。
	* ### 密集型的程序一般在達到性能極限時，CPU 佔用率仍然較低。這可能是因為任務本身需要大量 I/O 操作，而程序的邏輯做得不是很好，沒有充分利用處理器能力。
	* ### CPU 使用率較低，程序中會存在大量的 I/O 操作佔用時間，導致線程空餘時間很多，通常就需要開 CPU 核心數數倍的線程。
	* ### 其計算公式為: IO 密集型核心線程數 = CPU 核數 / (1 - 阻塞係數)。
	* ### 當線程進行 I/O 操作 CPU 空閒時，啟用其他線程繼續使用 CPU，以提高 CPU 的使用率。例如: 數據庫交互、文件上傳下載、網絡傳輸等。
* ### CPU 密集型任務與 IO 密集型任務的區別
	* ### CPU 密集型任務的特點是要進行大量的計算，消耗 CPU 資源，全靠 CPU 的運算能力。這種計算密集型任務雖然也可以用多任務完成，但是任務越多，花在任務切換的時間就越多，CPU 執行任務的效率就越低，所以，要最高效地利用 CPU，計算密集型任務同時進行的數量應當等於 CPU 的核心數，避免線程或進程的切換。
	* ### 計算密集型任務由於主要消耗 CPU 資源，因此，代碼運行效率至關重要。Python 這樣的腳本語言運行效率很低，完全不適合計算密集型任務。對於計算密集型任務，最好用 C 語言編寫。
	* ### IO 密集型任務的特點是 CPU 消耗很少，任務的大部分時間都在等待 IO 操作完成 (因為 IO 的速度遠遠低於 CPU 和內存的速度)。涉及到網絡、磁盤 IO 的任務都是 IO 密集型任務。
	* ### 對於 IO 密集型任務，線程數越多，CPU 效率越高，但也有一個限度。
* ### 一個計算為主的應用程序 (CPU 密集型程序)，多線程可以充分利用起所有的 CPU 核心數，比如說 16 核的 CPU，開 16 個線程的時候，可以同時跑 16 個線程的運算任務，此時是最大效率。但是如果線程數遠遠超出 CPU 核心數量，反而會使得任務效率下降，因為頻繁的切換線程或進程也是要消耗時間的。因此對於 CPU 密集型的任務來說，線程數等於 CPU 數是最好的了。
* ### 如果是一個磁盤或網絡為主的應用程序 (IO 密集型程序)，一個線程處在 IO 等待的時候，另一個線程還可以在 CPU 裡面跑，有時候 CPU 閒著沒事幹，所有的線程都在等著 IO，這時候他們就是同時的了，而單線程的話，此時還是在一個一個等待的。我們都知道 IO 的速度比起 CPU 來是很慢的。此時線程數可以是 CPU 核心數的數倍 (視情況而定)。
* ### CPU 密集型，使用 multiprocessing。
* ### IO 密集型，使用 multiprocessing.dummy。
* ### The concurrent.futures module provides a high-level interface for asynchronously executing callables.
* ### threading 重點摘要
	* ### 透過 context-switch 的方式實現。
	* ### 透過 CPU 的不斷切換 (context-switch)，實現平行的功能。
	* ### 大量使用 threading 執行平行的功能時，會因為大量的 context-switch，「實現了程式平行的功能，但也因為大量的 context-switch，使得程式執行速度更慢」。
* ### multiprocessing 重點摘要
	* ### multiprocessing 在資料傳遞上，會因為需要將資料轉移至其他 CPU 上進行運算。
	* ### 因此會需要考慮資料搬運的時間，而多核心真正的實現「平行運算的功能」，當任務較為複雜時，效率一定比較好。
* ### join() 方法可以等待子進程結束後再繼續往下運行 (更準確地說，在當前位置阻塞主進程，待執行 join() 的進程結束後再繼續執行主進程)，通常用於進程間的同步。(進一步地解釋，哪個子進程調用了 join 方法，主進程就要等該子進程執行完後才能繼續向下執行)
* ### multiprocessing.Pool 可取得回傳結果，並讓系統自動分配資源。
* ### multiprocessing.Process 不會回傳結果。
* ### 執行 pool 內的任務的時候，使用「map」將任務一個個分配下去。
* ### Pool 內可以使用參數 processes = 「想要的 CPU 核數量」，例如: pool = mp.Pool(processes=4) ，就是我們指定了 4個 CPU 核 (預設就是 CPU 的對應核心數量)。
* ### map 可以傳入一個 list 使其迭代，而 apply_async 不行。
* ### map 會等待 map 的任務執行完後，才執行接下來的主程式。
* ### apply_async 不等待 apply_async 的任務執行完，就會執行接下來的主程式。
* ### thread 可直接使用全域變數 (global) 交換資訊。
* ### multiprocess 需透過設定特定通道 (多核心執行的中央變數管理) 才能拿到資訊。
* ### thread 適合小任務、資訊共用的任務 (直接拿 global 資訊來用)。
* ### multiprocess 適合大任務、資訊獨立的任務 (把相關資訊交由其他核心處理後，不太需要拿取新資訊)。
* ### python 的 thread 實作使用 GIL (global interpreter lock) 保護程式取用資料衝突的機制。
* ### ![image](https://gitlab.com/ChiangWei/main/-/raw/master/Python/thread%20%E8%88%87%20multiprocess%20%E6%AF%94%E8%BC%83.png)
<br />

Reference
=====
### * Python 3.7 技術手冊
